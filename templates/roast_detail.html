{% extends "base.html" %}

{% block title %}{{ roast_session.name }} - Coffee Roaster Logger{% endblock %}

{% block content %}
<div class="px-2 sm:px-0">
    <!-- Header Section -->
    <div class="{% if roast_session.status == 'active' %}glass-card accent-danger border-l-4 border-red-500{% else %}glass-card card-primary{% endif %} rounded-xl p-6 mb-6">
        <div class="flex justify-between items-center mb-3">
            <div class="flex items-center">
                {% if roast_session.status == 'active' %}
                    <i class="fas fa-fire text-red-400 animate-pulse mr-3 text-xl"></i>
                    <h2 class="text-2xl font-bold text-red-400">{{ roast_session.name }}</h2>
                {% else %}
                    <i class="fas fa-check text-green-400 mr-3 text-xl"></i>
                    <h2 class="text-2xl font-bold text-amber-300">{{ roast_session.name }}</h2>
                {% endif %}
            </div>
            
            <div class="flex items-center space-x-3">
                {% if roast_session.status == 'active' %}
                    <button id="stopRoastBtn" class="bg-gradient-to-r from-red-600 to-red-700 hover:from-red-700 hover:to-red-800 text-white px-6 py-3 text-sm rounded-lg font-semibold transition-all duration-300 shadow-lg accent-danger">
                        <i class="fas fa-stop mr-2"></i>
                        Stop Roast
                    </button>
                {% endif %}
                <a href="/" class="bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white px-6 py-3 text-sm rounded-lg font-semibold transition-all duration-300 shadow-lg accent-info">
                    <i class="fas fa-arrow-left mr-2"></i>
                    Back
                </a>
            </div>
        </div>
        
        <div class="text-sm {% if roast_session.status == 'active' %}text-red-300{% else %}text-gray-300{% endif %} mb-4">
            <div class="flex items-center justify-between">
                <div>
                    Started: {{ roast_session.start_time | replace('T', ' ') | replace('.', ' ') | truncate(19, True, '') }}
                    {% if roast_session.end_time %}
                        | Ended: {{ roast_session.end_time | replace('T', ' ') | replace('.', ' ') | truncate(19, True, '') }}
                    {% endif %}
                </div>
                <div class="flex items-center space-x-2">
                    <span class="text-amber-300">Roaster:</span>
                    {% if roast_session.status == 'completed' %}
                        <div id="roasterDisplay" class="flex items-center">
                            <span id="roasterText" class="font-semibold text-amber-400">{{ roast_session.roaster_id or 'BHR2' }}</span>
                            <button id="editRoasterBtn" class="ml-2 text-blue-400 hover:text-blue-300">
                                <i class="fas fa-edit text-sm"></i>
                            </button>
                        </div>
                        <div id="roasterEdit" class="hidden flex items-center space-x-2">
                            <select id="roasterSelect" class="bg-gray-700 text-white px-2 py-1 rounded border border-gray-600 text-sm">
                            </select>
                            <button id="saveRoasterBtn" class="bg-green-600 hover:bg-green-700 text-white px-2 py-1 rounded text-sm">
                                <i class="fas fa-check"></i>
                            </button>
                            <button id="cancelRoasterBtn" class="bg-gray-600 hover:bg-gray-700 text-white px-2 py-1 rounded text-sm">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    {% else %}
                        <span class="font-semibold text-amber-400">{{ roast_session.roaster_id or 'BHR2' }}</span>
                    {% endif %}
                </div>
            </div>
        </div>
        
        <!-- Metrics Banner -->
        <div class="grid grid-cols-2 md:grid-cols-8 gap-4">
            <div class="glass-card rounded-lg p-4 border border-amber-400">
                <div class="text-sm text-amber-300">Duration</div>
                <div class="text-2xl font-bold text-amber-400" id="duration">-</div>
            </div>
            {% if roast_session.status == 'active' %}
            <div class="glass-card rounded-lg p-4 border border-red-400">
                <div class="flex items-center justify-between mb-1">
                    <div class="text-sm text-red-300">Current Temp</div>
                    <div class="w-3 h-3 rounded-full bg-green-500" id="tempStatusLight"></div>
                </div>
                <div class="text-2xl font-bold text-red-400" id="currentTemp">-</div>
            </div>
            <div class="glass-card rounded-lg p-4 border border-blue-400">
                <div class="text-sm text-blue-300">Current Humidity</div>
                <div class="text-2xl font-bold text-blue-400" id="currentHumidity">-</div>
            </div>
            {% else %}
            <div class="glass-card rounded-lg p-4 border border-gray-600">
                <div class="text-sm text-gray-300">Current Temp</div>
                <div class="text-2xl font-bold text-gray-400">-</div>
            </div>
            <div class="glass-card rounded-lg p-4 border border-gray-600">
                <div class="text-sm text-gray-300">Current Humidity</div>
                <div class="text-2xl font-bold text-gray-400">-</div>
            </div>
            {% endif %}
            {% if roast_session.status == 'active' %}
            <div class="glass-card rounded-lg p-4 border border-purple-400">
                <div class="text-sm text-purple-300">Current CO2</div>
                <div class="text-2xl font-bold text-purple-400" id="currentCO2">-</div>
            </div>
            <div class="glass-card rounded-lg p-4 border border-orange-400">
                <div class="text-sm text-orange-300">Current VOC</div>
                <div class="text-2xl font-bold text-orange-400" id="currentVOC">-</div>
            </div>
            {% else %}
            <div class="glass-card rounded-lg p-4 border border-gray-600">
                <div class="text-sm text-gray-300">Current CO2</div>
                <div class="text-2xl font-bold text-gray-400">-</div>
            </div>
            <div class="glass-card rounded-lg p-4 border border-gray-600">
                <div class="text-sm text-gray-300">Current VOC</div>
                <div class="text-2xl font-bold text-gray-400">-</div>
            </div>
            {% endif %}
            <div class="glass-card rounded-lg p-4 border border-red-400">
                <div class="text-sm text-red-300">Peak Temp</div>
                <div class="text-2xl font-bold text-red-400" id="peakTemp">-</div>
            </div>
            <div class="glass-card rounded-lg p-4 border border-blue-400">
                <div class="text-sm text-blue-300">Avg Humidity</div>
                <div class="text-2xl font-bold text-blue-400" id="avgHumidity">-</div>
            </div>
            <div class="glass-card rounded-lg p-4 border border-green-400">
                <div class="text-sm text-green-300">Data Points</div>
                <div class="text-2xl font-bold text-green-400" id="dataCount">{{ roast_data | length }}</div>
            </div>
        </div>
    </div>

    <!-- Chart -->
    <div class="glass-card rounded-xl p-6 card-primary">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-xl font-bold text-amber-300">
                <i class="fas fa-chart-line mr-2"></i>
                Roast Profile
            </h3>
            <div class="flex items-center space-x-4 flex-wrap">
                <div class="flex items-center">
                    <input type="checkbox" id="toggleTemp" class="mr-1" checked>
                    <div class="w-3 h-3 bg-green-500 rounded-full mr-2" id="tempLegendColor"></div>
                    <span class="text-sm text-green-300 cursor-pointer" id="tempLegendText" onclick="document.getElementById('toggleTemp').click()">Temperature (Â°C)</span>
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="toggleHumidity" class="mr-1" checked>
                    <div class="w-3 h-3 bg-blue-500 rounded-full mr-2"></div>
                    <span class="text-sm text-blue-300 cursor-pointer" onclick="document.getElementById('toggleHumidity').click()">Humidity (%)</span>
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="toggleCO2" class="mr-1" checked>
                    <div class="w-3 h-3 bg-purple-500 rounded-full mr-2"></div>
                    <span class="text-sm text-purple-300 cursor-pointer" onclick="document.getElementById('toggleCO2').click()">CO2 (ppm)</span>
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="toggleVOC" class="mr-1" checked>
                    <div class="w-3 h-3 bg-orange-500 rounded-full mr-2"></div>
                    <span class="text-sm text-orange-300 cursor-pointer" onclick="document.getElementById('toggleVOC').click()">VOC (ppb)</span>
                </div>
                <div class="flex items-center">
                    <input type="checkbox" id="toggleComputed" class="mr-1" checked>
                    <div class="w-3 h-3 bg-yellow-500 rounded-full mr-2"></div>
                    <span class="text-sm text-yellow-300 cursor-pointer" onclick="document.getElementById('toggleComputed').click()">Abs Humidity (g/mÂ³)</span>
                </div>
                <div class="flex items-center">
                    <div class="w-3 h-0.5 bg-red-500 mr-2"></div>
                    <span class="text-sm text-red-300">First Crack (FC)</span>
                </div>
                {% if roast_session.status == 'active' %}
                <button id="markFirstCrackBtn" class="bg-gradient-to-r from-red-600 to-red-700 hover:from-red-700 hover:to-red-800 text-white px-4 py-2 text-xs rounded-lg font-semibold transition-all duration-300 shadow-lg accent-danger">
                    <i class="fas fa-fire mr-1"></i>
                    <span id="markFCText">Mark FC</span>
                </button>
                {% endif %}
            </div>
        </div>
        
        <div class="relative" style="height: 480px;">
            <canvas id="roastChart"></canvas>
        </div>
    </div>

    <!-- Notes Section -->
    <div class="glass-card rounded-xl p-6 mt-6 card-primary">
        <div class="mb-4">
            <h3 class="text-xl font-bold text-amber-300 flex items-center">
                <i class="fas fa-sticky-note mr-2"></i>
                Roast Notes
                <button id="editNotesBtn" class="ml-2 text-blue-400 hover:text-blue-300 transition-colors duration-200" title="Edit Notes">
                    <i class="fas fa-pencil-alt text-lg"></i>
                </button>
            </h3>
        </div>
        
        <!-- Notes Display -->
        <div id="notesDisplay" class="min-h-[100px]">
            <div id="notesContent" class="prose prose-invert max-w-none">
                {% if roast_session.notes %}
                    {{ roast_session.notes }}
                {% else %}
                    <p class="text-gray-400 italic">No notes added yet. Click "Edit Notes" to add your observations, tasting notes, or process improvements.</p>
                {% endif %}
            </div>
        </div>
        
        <!-- Notes Editor (Hidden by default) -->
        <div id="notesEditor" class="hidden">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-4">
                <!-- Markdown Editor -->
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">
                        <i class="fas fa-edit mr-1"></i>
                        Edit Notes (Markdown supported)
                    </label>
                    <textarea id="notesTextarea" 
                              class="w-full h-64 bg-gray-800 text-white border border-gray-600 rounded-lg p-3 font-mono text-sm resize-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
                              placeholder="# Roast Notes&#10;&#10;## Process&#10;- Initial observations...&#10;&#10;## Tasting Notes&#10;- Aroma: ...&#10;- Flavor: ...&#10;&#10;## Improvements&#10;- Next time try..."></textarea>
                    <div class="flex justify-between items-center mt-2">
                        <div class="text-xs text-gray-400">
                            <i class="fab fa-markdown mr-1"></i>
                            Markdown formatting supported
                        </div>
                        <div class="text-xs text-gray-400">
                            <span id="charCount">0</span> / 5000 characters
                        </div>
                    </div>
                </div>
                
                <!-- Live Preview -->
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">
                        <i class="fas fa-eye mr-1"></i>
                        Live Preview
                    </label>
                    <div id="notesPreview" 
                         class="h-64 bg-gray-900 border border-gray-600 rounded-lg p-3 overflow-y-auto prose prose-invert prose-sm max-w-none">
                        <p class="text-gray-400 italic">Preview will appear here as you type...</p>
                    </div>
                </div>
            </div>
            
            <!-- Editor Controls -->
            <div class="flex justify-between items-center">
                <div class="flex space-x-2">
                    <button id="formatBold" class="px-2 py-1 bg-gray-700 text-white rounded hover:bg-gray-600 text-sm" title="Bold">
                        <i class="fas fa-bold"></i>
                    </button>
                    <button id="formatItalic" class="px-2 py-1 bg-gray-700 text-white rounded hover:bg-gray-600 text-sm" title="Italic">
                        <i class="fas fa-italic"></i>
                    </button>
                    <button id="formatHeader" class="px-2 py-1 bg-gray-700 text-white rounded hover:bg-gray-600 text-sm" title="Header">
                        <i class="fas fa-heading"></i>
                    </button>
                    <button id="formatList" class="px-2 py-1 bg-gray-700 text-white rounded hover:bg-gray-600 text-sm" title="List">
                        <i class="fas fa-list-ul"></i>
                    </button>
                    <button id="formatCode" class="px-2 py-1 bg-gray-700 text-white rounded hover:bg-gray-600 text-sm" title="Code">
                        <i class="fas fa-code"></i>
                    </button>
                </div>
                
                <div class="flex space-x-3">
                    <button id="cancelNotesBtn" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 text-sm rounded-lg font-semibold transition-all duration-300">
                        <i class="fas fa-times mr-2"></i>
                        Cancel
                    </button>
                    <button id="saveNotesBtn" class="bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white px-4 py-2 text-sm rounded-lg font-semibold transition-all duration-300 shadow-lg">
                        <i class="fas fa-save mr-2"></i>
                        Save Notes
                    </button>
                </div>
            </div>
        </div>
    </div>

</div>
{% endblock %}

{% block scripts %}
<script>
// Initialize Socket.IO connection
const socket = io();

// Custom plugin for first crack lines (both manual and predicted)
const firstCrackPlugin = {
    id: 'firstCrackLine',
    afterDraw: function(chart) {
        const ctx = chart.ctx;
        const chartArea = chart.chartArea;
        
        // Draw manual FC marker (red)
        if (chart.fcManualX !== null && chart.fcManualX !== undefined) {
            const x = chart.scales.x.getPixelForValue(chart.fcManualX);
            
            if (x >= chartArea.left && x <= chartArea.right) {
                ctx.save();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = 'rgb(239, 68, 68)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, chartArea.top);
                ctx.lineTo(x, chartArea.bottom);
                ctx.stroke();
                
                // Draw label
                const labelText = chart.fcManualLabel || 'FC (Manual)';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                
                // Background for label
                const textMetrics = ctx.measureText(labelText);
                const labelWidth = textMetrics.width + 8;
                const labelHeight = 20;
                const labelX = x - labelWidth / 2;
                const labelY = chartArea.top + 10;
                
                ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                ctx.fillRect(labelX, labelY, labelWidth, labelHeight);
                
                // Label text
                ctx.fillStyle = 'white';
                ctx.fillText(labelText, x, labelY + 14);
                
                ctx.restore();
            }
        }
        
        // Draw predicted FC marker (orange)
        if (chart.fcPredictedX !== null && chart.fcPredictedX !== undefined) {
            const x = chart.scales.x.getPixelForValue(chart.fcPredictedX);
            
            if (x >= chartArea.left && x <= chartArea.right) {
                ctx.save();
                ctx.setLineDash([10, 3, 3, 3]); // Different dash pattern
                ctx.strokeStyle = 'rgb(251, 146, 60)'; // Orange color
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, chartArea.top);
                ctx.lineTo(x, chartArea.bottom);
                ctx.stroke();
                
                // Draw label
                const labelText = chart.fcPredictedLabel || 'FC (Predicted)';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                
                // Background for label
                const textMetrics = ctx.measureText(labelText);
                const labelWidth = textMetrics.width + 8;
                const labelHeight = 20;
                const labelX = x - labelWidth / 2;
                const labelY = chartArea.top + 35; // Offset below manual FC label
                
                ctx.fillStyle = 'rgba(251, 146, 60, 0.8)'; // Orange background
                ctx.fillRect(labelX, labelY, labelWidth, labelHeight);
                
                // Label text
                ctx.fillStyle = 'white';
                ctx.fillText(labelText, x, labelY + 14);
                
                ctx.restore();
            }
        }
    }
};

// Register custom plugin
Chart.register(firstCrackPlugin);

// Chart configuration
const ctx = document.getElementById('roastChart').getContext('2d');
const chart = new Chart(ctx, {
    type: 'line',
    data: {
        labels: [],
        datasets: [{
            label: 'Temperature (Â°C)',
            data: [],
            borderColor: 'rgb(34, 197, 94)',
            backgroundColor: 'rgba(34, 197, 94, 0.1)',
            tension: 0.1,
            yAxisID: 'y',
            pointRadius: 0,
            pointHoverRadius: 3
        }, {
            label: 'Humidity (%)',
            data: [],
            borderColor: 'rgb(59, 130, 246)',
            backgroundColor: 'rgba(59, 130, 246, 0.1)',
            tension: 0.1,
            yAxisID: 'y1',
            pointRadius: 0,
            pointHoverRadius: 3
        }, {
            label: 'CO2 (ppm)',
            data: [],
            borderColor: 'rgb(147, 51, 234)',
            backgroundColor: 'rgba(147, 51, 234, 0.1)',
            tension: 0.1,
            yAxisID: 'y2',
            pointRadius: 0,
            pointHoverRadius: 3
        }, {
            label: 'VOC (ppb)',
            data: [],
            borderColor: 'rgb(249, 115, 22)',
            backgroundColor: 'rgba(249, 115, 22, 0.1)',
            tension: 0.1,
            yAxisID: 'y3',
            pointRadius: 0,
            pointHoverRadius: 3
        }, {
            label: 'Abs Humidity (g/mÂ³)',
            data: [],
            borderColor: 'rgb(234, 179, 8)',
            backgroundColor: 'rgba(234, 179, 8, 0.1)',
            tension: 0.1,
            yAxisID: 'y4',
            pointRadius: 0,
            pointHoverRadius: 3
        }]
    },
    options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
            mode: 'index',
            intersect: false,
        },
        scales: {
            x: {
                display: true,
                type: 'linear',
                title: {
                    display: true,
                    text: 'Time (MM:SS)'
                },
                min: 0,
                ticks: {
                    stepSize: 0.5,  // Show ticks every 30 seconds
                    callback: function(value) {
                        const minutes = Math.floor(value);
                        const seconds = Math.floor((value % 1) * 60);
                        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                }
            },
            y: {
                type: 'linear',
                display: true,
                position: 'left',
                title: {
                    display: true,
                    text: 'Temperature (Â°C)'
                },
                grid: {
                    drawOnChartArea: false,
                },
            },
            y1: {
                type: 'linear',
                display: true,
                position: 'right',
                title: {
                    display: true,
                    text: 'Humidity (%)'
                },
                grid: {
                    drawOnChartArea: false,
                },
            },
            y2: {
                type: 'linear',
                display: false,
                position: 'left',
                title: {
                    display: false,
                    text: 'CO2 (ppm)'
                },
                grid: {
                    drawOnChartArea: false,
                },
            },
            y3: {
                type: 'linear',
                display: false,
                position: 'right',
                title: {
                    display: false,
                    text: 'VOC (ppb)'
                },
                grid: {
                    drawOnChartArea: false,
                },
            },
            y4: {
                type: 'linear',
                display: true,
                position: 'left',
                title: {
                    display: true,
                    text: 'Abs Humidity (g/mÂ³)'
                },
                grid: {
                    drawOnChartArea: false,
                },
                offset: true
            }
        },
        plugins: {
            legend: {
                display: false
            },
            tooltip: {
                callbacks: {
                    title: function(context) {
                        const value = context[0].parsed.x;
                        const minutes = Math.floor(value);
                        const seconds = Math.floor((value % 1) * 60);
                        return `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                }
            }
        }
    }
});

// Initialize chart with existing data
const roastData = {{ roast_data | tojson }};
const roastId = '{{ roast_session.id }}';
const isActive = {{ 'true' if roast_session.status == 'active' else 'false' }};

// Process and display data
console.log('Total roast data points received:', roastData.length);
console.log('Data point types:', roastData.map(p => p.metric_type).filter((v, i, a) => a.indexOf(v) === i));

if (roastData.length > 0) {
    const startTime = new Date(roastData[0].timestamp);
    const tempData = [];
    const humidityData = [];
    const co2Data = [];
    const vocData = [];
    const computedData = [];
    const labels = [];
    
    let totalTemp = 0;
    let totalHumidity = 0;
    let totalCO2 = 0;
    let totalVOC = 0;
    let tempCount = 0;
    let humidityCount = 0;
    let co2Count = 0;
    let vocCount = 0;
    let maxTemp = -Infinity;
    let maxCO2 = -Infinity;
    let maxVOC = -Infinity;
    
    roastData.forEach((point, index) => {
        const timestamp = new Date(point.timestamp);
        const elapsedMinutes = (timestamp - startTime) / 60000;
        const label = `${Math.floor(elapsedMinutes)}:${String(Math.floor((elapsedMinutes % 1) * 60)).padStart(2, '0')}`;
        
        // Debug logging for first few points
        if (index < 5) {
            console.log(`Point ${index}: ${point.timestamp} -> ${timestamp.toISOString()} -> ${elapsedMinutes} min`);
        }
        
        if (point.metric_type === 'temperature') {
            tempData.push({x: elapsedMinutes, y: point.value});
            totalTemp += point.value;
            tempCount++;
            maxTemp = Math.max(maxTemp, point.value);
        } else if (point.metric_type === 'humidity') {
            humidityData.push({x: elapsedMinutes, y: point.value});
            totalHumidity += point.value;
            humidityCount++;
        } else if (point.metric_type === 'co2') {
            co2Data.push({x: elapsedMinutes, y: point.value});
            totalCO2 += point.value;
            co2Count++;
            maxCO2 = Math.max(maxCO2, point.value);
        } else if (point.metric_type === 'voc') {
            vocData.push({x: elapsedMinutes, y: point.value});
            totalVOC += point.value;
            vocCount++;
            maxVOC = Math.max(maxVOC, point.value);
        } else if (point.metric_type === 'computed') {
            computedData.push({x: elapsedMinutes, y: point.value});
        }
    });
    
    // Debug: Log chart data
    console.log('Temperature data points:', tempData.slice(0, 5));
    console.log('Humidity data points:', humidityData.slice(0, 5));
    console.log('CO2 data points:', co2Data.slice(0, 5));
    console.log('VOC data points:', vocData.slice(0, 5));
    console.log('Computed data points:', computedData.slice(0, 5));
    
    // Update chart
    chart.data.datasets[0].data = tempData;
    chart.data.datasets[1].data = humidityData;
    chart.data.datasets[2].data = co2Data;
    chart.data.datasets[3].data = vocData;
    chart.data.datasets[4].data = computedData;
    chart.update();
    
    // Update statistics
    document.getElementById('peakTemp').textContent = maxTemp > -Infinity ? `${maxTemp.toFixed(1)}Â°C` : '-';
    document.getElementById('avgHumidity').textContent = humidityCount > 0 ? `${(totalHumidity / humidityCount).toFixed(1)}%` : '-';
    
    // Calculate duration
    const endTime = new Date('{{ roast_session.end_time }}' || new Date());
    const duration = (endTime - startTime) / 1000;
    const minutes = Math.floor(duration / 60);
    const seconds = Math.floor(duration % 60);
    document.getElementById('duration').textContent = `${minutes}m ${seconds}s`;
}

// Socket.IO event handlers for live updates
let roastStartTime = roastData[0] ? new Date(roastData[0].timestamp) : null;

console.log('Roast detail page loaded for roast:', roastId, 'Active:', isActive);

// Polling for live data updates (1 second interval)
let lastUpdateTimestamp = '';

// Function to update temperature status light
function updateTemperatureStatusLight(isAlert) {
    const statusLight = document.getElementById('tempStatusLight');
    if (statusLight) {
        if (isAlert) {
            statusLight.className = 'w-3 h-3 rounded-full bg-red-500 animate-pulse';
        } else {
            statusLight.className = 'w-3 h-3 rounded-full bg-green-500';
        }
    }
}

// Function to update temperature chart color based on alert status
function updateTemperatureChartColor(isAlert) {
    const legendColor = document.getElementById('tempLegendColor');
    const legendText = document.getElementById('tempLegendText');
    
    if (isAlert) {
        chart.data.datasets[0].borderColor = 'rgb(239, 68, 68)';
        chart.data.datasets[0].backgroundColor = 'rgba(239, 68, 68, 0.1)';
        if (legendColor) legendColor.className = 'w-3 h-3 bg-red-500 rounded-full mr-2';
        if (legendText) legendText.className = 'text-sm text-red-300';
    } else {
        chart.data.datasets[0].borderColor = 'rgb(34, 197, 94)';
        chart.data.datasets[0].backgroundColor = 'rgba(34, 197, 94, 0.1)';
        if (legendColor) legendColor.className = 'w-3 h-3 bg-green-500 rounded-full mr-2';
        if (legendText) legendText.className = 'text-sm text-green-300';
    }
}

async function pollForLiveData() {
    if (!isActive) return;
    
    try {
        const response = await fetch(`/api/roasts/${roastId}/live-data?since=${lastUpdateTimestamp}`);
        const result = await response.json();
        
        if (result.data && result.data.length > 0) {
            console.log('ðŸŸ¢ CHART received live data:', result.data);
            
            // Process new data points
            result.data.forEach(dataPoint => {
                const timestamp = new Date(dataPoint.timestamp);
                
                // Set start time if not already set
                if (!roastStartTime) {
                    roastStartTime = timestamp;
                    console.log('Set roast start time:', roastStartTime);
                }
                
                const elapsedMinutes = (timestamp - roastStartTime) / 60000;
                
                if (dataPoint.metric_type === 'temperature') {
                    chart.data.datasets[0].data.push({x: elapsedMinutes, y: dataPoint.value});
                    const currentTempElement = document.getElementById('currentTemp');
                    if (currentTempElement) {
                        currentTempElement.textContent = `${dataPoint.value.toFixed(1)}Â°C`;
                    }
                    
                    // Update peak temperature
                    const peakTempElement = document.getElementById('peakTemp');
                    if (peakTempElement) {
                        const currentPeak = parseFloat(peakTempElement.textContent) || 0;
                        if (dataPoint.value > currentPeak) {
                            peakTempElement.textContent = `${dataPoint.value.toFixed(1)}Â°C`;
                        }
                    }
                } else if (dataPoint.metric_type === 'humidity') {
                    chart.data.datasets[1].data.push({x: elapsedMinutes, y: dataPoint.value});
                    const currentHumidityElement = document.getElementById('currentHumidity');
                    if (currentHumidityElement) {
                        currentHumidityElement.textContent = `${dataPoint.value.toFixed(1)}%`;
                    }
                    
                    // Update average humidity
                    const humidityData = chart.data.datasets[1].data;
                    if (humidityData.length > 0) {
                        const avgHumidity = humidityData.reduce((sum, point) => sum + point.y, 0) / humidityData.length;
                        const avgHumidityElement = document.getElementById('avgHumidity');
                        if (avgHumidityElement) {
                            avgHumidityElement.textContent = `${avgHumidity.toFixed(1)}%`;
                        }
                    }
                } else if (dataPoint.metric_type === 'co2') {
                    chart.data.datasets[2].data.push({x: elapsedMinutes, y: dataPoint.value});
                    const currentCO2Element = document.getElementById('currentCO2');
                    if (currentCO2Element) {
                        currentCO2Element.textContent = `${dataPoint.value.toFixed(0)} ppm`;
                    }
                } else if (dataPoint.metric_type === 'voc') {
                    chart.data.datasets[3].data.push({x: elapsedMinutes, y: dataPoint.value});
                    const currentVOCElement = document.getElementById('currentVOC');
                    if (currentVOCElement) {
                        currentVOCElement.textContent = `${dataPoint.value.toFixed(0)} ppb`;
                    }
                } else if (dataPoint.metric_type === 'computed') {
                    chart.data.datasets[4].data.push({x: elapsedMinutes, y: dataPoint.value});
                }
                
                // Update data count
                const dataCountElement = document.getElementById('dataCount');
                if (dataCountElement) {
                    const currentCount = parseInt(dataCountElement.textContent) || 0;
                    dataCountElement.textContent = currentCount + 1;
                }
                
                // Update duration
                const duration = (timestamp - roastStartTime) / 1000;
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                const durationElement = document.getElementById('duration');
                if (durationElement) {
                    durationElement.textContent = `${minutes}m ${seconds}s`;
                }
            });
            
            // Update chart after processing all data points
            chart.update('none');
            
            // Update temperature status light and chart color
            updateTemperatureStatusLight(result.temperature_alert);
            updateTemperatureChartColor(result.temperature_alert);
            
            // Auto-scale the x-axis to show recent data
            const allData = [
                ...chart.data.datasets[0].data, 
                ...chart.data.datasets[1].data,
                ...chart.data.datasets[2].data,
                ...chart.data.datasets[3].data,
                ...chart.data.datasets[4].data
            ];
            if (allData.length > 0) {
                const maxTime = Math.max(...allData.map(p => p.x));
                if (maxTime > 10) { // If more than 10 minutes, show last 10 minutes
                    chart.options.scales.x.min = Math.max(0, maxTime - 10);
                    chart.options.scales.x.max = maxTime + 1;
                    chart.update('none');
                }
            }
            
            // Update timestamp for next poll
            lastUpdateTimestamp = result.timestamp;
            console.log('Updated chart with new data points');
        }
        
        // Update temperature status light and chart color even if no new data
        if (result.hasOwnProperty('temperature_alert')) {
            updateTemperatureStatusLight(result.temperature_alert);
            updateTemperatureChartColor(result.temperature_alert);
        }
        
        // Update FC markers if FC data is available in the response
        if (result.first_crack_event || result.first_crack_prediction) {
            const fcSummary = {
                manual: result.first_crack_event,
                predicted: result.first_crack_prediction
            };
            updateFirstCrackMarkers(fcSummary);
        }
        
        // Stop polling if roast is no longer active
        if (!result.is_active) {
            console.log('Roast no longer active, stopping polling');
            clearInterval(pollingInterval);
            setTimeout(() => location.reload(), 1000);
        }
        
    } catch (error) {
        console.error('Error polling for live data:', error);
    }
}

// Start polling if roast is active
let pollingInterval;
if (isActive) {
    console.log('Starting live data polling for roast:', roastId);
    
    // Fetch UI configuration for refresh rate
    fetch('/api/config')
        .then(response => response.json())
        .then(config => {
            const refreshRate = config.ui?.CHART_REFRESH_RATE_MS || 2000;
            console.log('Using chart refresh rate:', refreshRate, 'ms');
            pollingInterval = setInterval(pollForLiveData, refreshRate);
        })
        .catch(error => {
            console.error('Error fetching config, using default refresh rate:', error);
            pollingInterval = setInterval(pollForLiveData, 2000); // Default fallback
        });
}

// Handle stop roast
const stopRoastBtn = document.getElementById('stopRoastBtn');
if (stopRoastBtn) {
    stopRoastBtn.addEventListener('click', async () => {
        try {
            const response = await fetch(`/api/roasts/${roastId}/stop`, {
                method: 'PUT'
            });
            
            if (response.ok) {
                location.reload();
            } else {
                const error = await response.json();
                alert('Error stopping roast: ' + error.error);
            }
        } catch (error) {
            alert('Error stopping roast: ' + error.message);
        }
    });
}

socket.on('roast_stopped', (data) => {
    if (data.roast_id === roastId) {
        setTimeout(() => location.reload(), 1000);
    }
});

// Toggle functionality for chart datasets
function setupToggleControls() {
    const toggles = [
        { id: 'toggleTemp', dataset: 0, axis: 'y' },
        { id: 'toggleHumidity', dataset: 1, axis: 'y1' },
        { id: 'toggleCO2', dataset: 2, axis: 'y2' },
        { id: 'toggleVOC', dataset: 3, axis: 'y3' },
        { id: 'toggleComputed', dataset: 4, axis: 'y4' }
    ];
    
    toggles.forEach(toggle => {
        const checkbox = document.getElementById(toggle.id);
        if (checkbox) {
            checkbox.addEventListener('change', function() {
                const dataset = chart.data.datasets[toggle.dataset];
                const axis = chart.options.scales[toggle.axis];
                
                if (this.checked) {
                    dataset.hidden = false;
                    if (toggle.axis === 'y' || toggle.axis === 'y1' || toggle.axis === 'y4') {
                        axis.display = true;
                    }
                } else {
                    dataset.hidden = true;
                    // Only hide axis if it's not a primary axis (y, y1, y4 are visible by default)
                    if (toggle.axis === 'y2' || toggle.axis === 'y3') {
                        axis.display = false;
                    }
                }
                chart.update();
            });
        }
    });
}

// Initialize toggle controls after chart is created
setupToggleControls();

// First crack functionality
let firstCrackEvent = null;

function updateFirstCrackMarkers(fcSummary) {
    // Clear existing markers
    chart.fcManualX = null;
    chart.fcManualLabel = null;
    chart.fcPredictedX = null;
    chart.fcPredictedLabel = null;
    
    if (fcSummary && fcSummary.manual) {
        const fcTimestamp = new Date(fcSummary.manual.timestamp);
        const elapsedMinutes = (fcTimestamp - roastStartTime) / 60000;
        chart.fcManualX = elapsedMinutes;
        chart.fcManualLabel = 'FC (Manual)';
        console.log(`ðŸ”¥ Manual FC marker at ${elapsedMinutes.toFixed(1)} minutes`);
    }
    
    if (fcSummary && fcSummary.predicted) {
        const fcTimestamp = new Date(fcSummary.predicted.timestamp);
        const elapsedMinutes = (fcTimestamp - roastStartTime) / 60000;
        chart.fcPredictedX = elapsedMinutes;
        chart.fcPredictedLabel = `FC (Predicted ${(fcSummary.predicted.confidence_score * 100).toFixed(0)}%)`;
        console.log(`ðŸ”¥ Predicted FC marker at ${elapsedMinutes.toFixed(1)} minutes`);
    }
    
    chart.update('none');
}

// Legacy function for backward compatibility
function updateFirstCrackMarker(fcEvent) {
    if (!fcEvent) {
        chart.fcManualX = null;
        chart.fcManualLabel = null;
        chart.update('none');
        return;
    }
    
    const fcTimestamp = new Date(fcEvent.timestamp);
    const elapsedMinutes = (fcTimestamp - roastStartTime) / 60000;
    
    if (fcEvent.detection_method === 'manual') {
        chart.fcManualX = elapsedMinutes;
        chart.fcManualLabel = 'FC (Manual)';
    } else if (fcEvent.detection_method === 'live_prediction') {
        chart.fcManualX = elapsedMinutes;
        chart.fcManualLabel = `FC (Live ${(fcEvent.confidence_score * 100).toFixed(0)}%)`;
    } else {
        chart.fcPredictedX = elapsedMinutes;
        chart.fcPredictedLabel = `FC (Predicted ${(fcEvent.confidence_score * 100).toFixed(0)}%)`;
    }
    
    chart.update('none');
    console.log(`ðŸ”¥ First crack marker updated at ${elapsedMinutes.toFixed(1)} minutes`);
}

function markFirstCrackManually() {
    console.log('ðŸ”¥ markFirstCrackManually() called');
    console.log('Current roastId:', roastId);
    console.log('Current firstCrackEvent:', firstCrackEvent);
    
    // If FC already exists, delete it first, then mark new one
    const markFC = () => {
        console.log('ðŸ”¥ Executing markFC() - making POST request');
        
        const requestBody = {
            notes: 'Manually marked via UI'
        };
        console.log('Request body:', requestBody);
        fetch(`/api/roasts/${roastId}/first-crack`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                notes: 'Manually marked via UI'
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                console.error('Error marking first crack:', data.error);
            } else {
                console.log('First crack marked successfully:', data);
                // The socket event will update the UI automatically
            }
        })
        .catch(error => {
            console.error('Error marking first crack:', error);
        });
    };
    
    if (firstCrackEvent) {
        // Delete existing FC first, then mark new one
        fetch(`/api/roasts/${roastId}/first-crack`, {
            method: 'DELETE'
        })
        .then(response => response.json())
        .then(data => {
            console.log('Previous first crack deleted:', data);
            firstCrackEvent = null;
            updateFirstCrackMarker(null);
            markFC();
        })
        .catch(error => {
            console.error('Error deleting previous first crack:', error);
            markFC(); // Try to mark anyway
        });
    } else {
        markFC();
    }
}

// Load both manual and predicted first crack data on page load
async function loadFirstCrackData() {
    try {
        // Fetch manual FC event
        const manualResponse = await fetch(`/api/roasts/${roastId}/first-crack`);
        let manualFC = null;
        if (manualResponse.ok) {
            manualFC = await manualResponse.json();
            firstCrackEvent = manualFC; // Keep for backward compatibility
        } else if (manualResponse.status !== 404) {
            console.error('Error fetching manual FC:', manualResponse.status);
        }
        
        // Fetch predicted FC
        const predictedResponse = await fetch(`/api/roasts/${roastId}/first-crack-prediction`);
        let predictedFC = null;
        if (predictedResponse.ok) {
            predictedFC = await predictedResponse.json();
        } else if (predictedResponse.status !== 404) {
            console.error('Error fetching predicted FC:', predictedResponse.status);
        }
        
        // Update markers with both manual and predicted
        const fcSummary = {
            manual: manualFC,
            predicted: predictedFC
        };
        updateFirstCrackMarkers(fcSummary);
        
        console.log('Loaded FC data:', fcSummary);
        
        // If no prediction exists and roast is completed, generate one
        if (!predictedFC && !isActive) {
            generatePrediction();
        }
        
    } catch (error) {
        console.error('Error loading first crack data:', error);
    }
}

// Generate FC prediction for completed roasts
async function generatePrediction() {
    try {
        console.log('Generating FC prediction for roast:', roastId);
        const response = await fetch(`/api/roasts/${roastId}/first-crack-prediction`, {
            method: 'POST'
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log('FC prediction generated:', result);
            // Reload the FC data to show the new prediction
            loadFirstCrackData();
        } else {
            const error = await response.json();
            console.log('FC prediction not generated:', error.error);
        }
    } catch (error) {
        console.error('Error generating FC prediction:', error);
    }
}

// Load FC data when page loads
loadFirstCrackData();

// Socket event handlers for first crack
socket.on('first_crack_detected', (data) => {
    if (data.roast_id === roastId) {
        firstCrackEvent = data;
        updateFirstCrackMarker(data);
        
        // Show notification for manual detection
        const notification = document.createElement('div');
        notification.className = 'fixed top-4 right-4 bg-red-600 text-white px-6 py-3 rounded-lg shadow-lg z-50';
        notification.innerHTML = `
            <div class="flex items-center">
                <i class="fas fa-fire mr-2"></i>
                <span>First Crack Detected! (${(data.confidence_score * 100).toFixed(0)}% confidence)</span>
            </div>
        `;
        document.body.appendChild(notification);
        
        // Remove notification after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 5000);
    }
});

// Socket event handler for live prediction updates
socket.on('first_crack_predicted', (data) => {
    if (data.roast_id === roastId) {
        // Reload FC data to get updated prediction
        loadFirstCrackData();
        
        // Show subtle notification for prediction updates
        const notification = document.createElement('div');
        notification.className = 'fixed top-4 right-4 bg-orange-500 text-white px-6 py-3 rounded-lg shadow-lg z-50';
        notification.innerHTML = `
            <div class="flex items-center">
                <i class="fas fa-chart-line mr-2"></i>
                <span>FC Prediction Updated (${(data.confidence_score * 100).toFixed(0)}% confidence)</span>
            </div>
        `;
        document.body.appendChild(notification);
        
        // Remove notification after 3 seconds (shorter for predictions)
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
    }
});

// Manual first crack button
const markFCBtn = document.getElementById('markFirstCrackBtn');
console.log('Mark FC button element:', markFCBtn);
if (markFCBtn) {
    console.log('Attaching click handler to Mark FC button');
    markFCBtn.addEventListener('click', function(e) {
        console.log('Mark FC button clicked!');
        e.preventDefault();
        markFirstCrackManually();
    });
} else {
    console.log('Mark FC button not found on page');
}

// Roaster ID editing functionality
const editRoasterBtn = document.getElementById('editRoasterBtn');
const saveRoasterBtn = document.getElementById('saveRoasterBtn');
const cancelRoasterBtn = document.getElementById('cancelRoasterBtn');
const roasterDisplay = document.getElementById('roasterDisplay');
const roasterEdit = document.getElementById('roasterEdit');
const roasterText = document.getElementById('roasterText');
const roasterSelect = document.getElementById('roasterSelect');

let originalRoasterId = '';

// Load roaster options into the select dropdown
async function loadRoasterOptions() {
    if (!roasterSelect) return;
    
    try {
        const response = await fetch('/api/config');
        const config = await response.json();
        const roasterIds = config.roaster_ids || ['BHR2'];
        
        // Clear existing options
        roasterSelect.innerHTML = '';
        
        // Add configured roaster options
        roasterIds.forEach(roasterId => {
            const option = document.createElement('option');
            option.value = roasterId;
            option.textContent = roasterId;
            roasterSelect.appendChild(option);
        });
        
    } catch (error) {
        console.error('Error loading roaster options:', error);
    }
}

// Enter edit mode
function enterEditMode() {
    if (!roasterDisplay || !roasterEdit || !roasterText || !roasterSelect) return;
    
    originalRoasterId = roasterText.textContent;
    roasterSelect.value = originalRoasterId;
    
    roasterDisplay.classList.add('hidden');
    roasterEdit.classList.remove('hidden');
}

// Exit edit mode
function exitEditMode() {
    if (!roasterDisplay || !roasterEdit) return;
    
    roasterDisplay.classList.remove('hidden');
    roasterEdit.classList.add('hidden');
}

// Save roaster ID changes
async function saveRoasterChange() {
    if (!roasterSelect || !roasterText) return;
    
    const newRoasterId = roasterSelect.value;
    
    try {
        const response = await fetch(`/api/roasts/${roastId}/roaster`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                roaster_id: newRoasterId
            })
        });
        
        if (response.ok) {
            roasterText.textContent = newRoasterId;
            exitEditMode();
            
            // Show success notification
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-green-600 text-white px-6 py-3 rounded-lg shadow-lg z-50';
            notification.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-check mr-2"></i>
                    <span>Roaster ID updated to ${newRoasterId}</span>
                </div>
            `;
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        } else {
            const error = await response.json();
            alert('Error updating roaster ID: ' + error.error);
        }
    } catch (error) {
        alert('Error updating roaster ID: ' + error.message);
    }
}

// Event listeners for roaster editing
if (editRoasterBtn) {
    editRoasterBtn.addEventListener('click', enterEditMode);
}

if (saveRoasterBtn) {
    saveRoasterBtn.addEventListener('click', saveRoasterChange);
}

if (cancelRoasterBtn) {
    cancelRoasterBtn.addEventListener('click', exitEditMode);
}

// Load roaster options on page load
loadRoasterOptions();

// Notes functionality
const editNotesBtn = document.getElementById('editNotesBtn');
const notesDisplay = document.getElementById('notesDisplay');
const notesEditor = document.getElementById('notesEditor');
const notesContent = document.getElementById('notesContent');
const notesTextarea = document.getElementById('notesTextarea');
const notesPreview = document.getElementById('notesPreview');
const saveNotesBtn = document.getElementById('saveNotesBtn');
const cancelNotesBtn = document.getElementById('cancelNotesBtn');
const charCount = document.getElementById('charCount');

// Formatting buttons
const formatBold = document.getElementById('formatBold');
const formatItalic = document.getElementById('formatItalic');
const formatHeader = document.getElementById('formatHeader');
const formatList = document.getElementById('formatList');
const formatCode = document.getElementById('formatCode');

let originalNotes = '';
let isEditingNotes = false;

// Initialize notes content with current notes
function initializeNotes() {
    const currentNotes = '{{ roast_session.notes | default("") | replace("\\", "\\\\") | replace("\"", "\\\"") | replace("\n", "\\n") | replace("\r", "") }}';
    originalNotes = currentNotes;
    
    if (currentNotes) {
        renderMarkdown(currentNotes, notesContent);
    }
}

// Render Markdown to HTML
function renderMarkdown(markdown, targetElement) {
    if (typeof marked !== 'undefined') {
        // Configure marked for security
        marked.setOptions({
            breaks: true,
            gfm: true,
            sanitize: false, // We trust our own content
            smartLists: true,
            smartypants: false
        });
        
        const html = marked.parse(markdown);
        targetElement.innerHTML = html;
    } else {
        // Fallback to plain text with basic formatting
        targetElement.innerHTML = markdown.replace(/\n/g, '<br>');
    }
}

// Update character count
function updateCharCount() {
    const count = notesTextarea.value.length;
    charCount.textContent = count;
    
    if (count > 5000) {
        charCount.className = 'text-red-400 font-bold';
        saveNotesBtn.disabled = true;
        saveNotesBtn.classList.add('opacity-50', 'cursor-not-allowed');
    } else if (count > 4500) {
        charCount.className = 'text-yellow-400 font-bold';
        saveNotesBtn.disabled = false;
        saveNotesBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    } else {
        charCount.className = 'text-gray-400';
        saveNotesBtn.disabled = false;
        saveNotesBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    }
}

// Update live preview
function updatePreview() {
    const markdown = notesTextarea.value;
    if (markdown.trim()) {
        renderMarkdown(markdown, notesPreview);
    } else {
        notesPreview.innerHTML = '<p class="text-gray-400 italic">Preview will appear here as you type...</p>';
    }
}

// Enter edit mode
function enterNotesEditMode() {
    isEditingNotes = true;
    notesTextarea.value = originalNotes;
    updateCharCount();
    updatePreview();
    
    notesDisplay.classList.add('hidden');
    notesEditor.classList.remove('hidden');
    
    editNotesBtn.disabled = true;
    editNotesBtn.classList.add('opacity-50', 'cursor-not-allowed');
    editNotesBtn.title = 'Editing...';
    
    // Focus textarea
    notesTextarea.focus();
}

// Exit edit mode
function exitNotesEditMode() {
    isEditingNotes = false;
    
    notesDisplay.classList.remove('hidden');
    notesEditor.classList.add('hidden');
    
    editNotesBtn.disabled = false;
    editNotesBtn.classList.remove('opacity-50', 'cursor-not-allowed');
    editNotesBtn.title = 'Edit Notes';
}

// Check for unsaved changes
function hasUnsavedChanges() {
    return notesTextarea.value !== originalNotes;
}

// Insert markdown formatting
function insertFormatting(before, after = '', placeholder = 'text') {
    const start = notesTextarea.selectionStart;
    const end = notesTextarea.selectionEnd;
    const selectedText = notesTextarea.value.substring(start, end) || placeholder;
    const replacement = before + selectedText + after;
    
    notesTextarea.value = notesTextarea.value.substring(0, start) + replacement + notesTextarea.value.substring(end);
    
    // Set cursor position
    const newCursorPos = start + before.length + selectedText.length + after.length;
    notesTextarea.setSelectionRange(newCursorPos, newCursorPos);
    notesTextarea.focus();
    
    updateCharCount();
    updatePreview();
}

// Save notes
async function saveNotes() {
    const notes = notesTextarea.value;
    
    try {
        const response = await fetch(`/api/roasts/${roastId}/notes`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                notes: notes
            })
        });
        
        if (response.ok) {
            originalNotes = notes;
            renderMarkdown(notes, notesContent);
            exitNotesEditMode();
            
            // Success notification
            Swal.fire({
                icon: 'success',
                title: 'Notes Saved!',
                text: 'Your roast notes have been saved successfully.',
                toast: true,
                position: 'top-end',
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true,
                background: '#1f2937',
                color: '#f3f4f6'
            });
        } else {
            const error = await response.json();
            throw new Error(error.error || 'Failed to save notes');
        }
    } catch (error) {
        console.error('Error saving notes:', error);
        Swal.fire({
            icon: 'error',
            title: 'Save Failed',
            text: 'Failed to save notes: ' + error.message,
            background: '#1f2937',
            color: '#f3f4f6'
        });
    }
}

// Cancel editing with confirmation if there are unsaved changes
function cancelNotesEditing() {
    if (hasUnsavedChanges()) {
        Swal.fire({
            title: 'Discard Changes?',
            text: 'You have unsaved changes. Are you sure you want to discard them?',
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Discard',
            cancelButtonText: 'Keep Editing',
            confirmButtonColor: '#ef4444',
            cancelButtonColor: '#6b7280',
            background: '#1f2937',
            color: '#f3f4f6'
        }).then((result) => {
            if (result.isConfirmed) {
                exitNotesEditMode();
            }
        });
    } else {
        exitNotesEditMode();
    }
}

// Event listeners
if (editNotesBtn) {
    editNotesBtn.addEventListener('click', enterNotesEditMode);
}

if (saveNotesBtn) {
    saveNotesBtn.addEventListener('click', saveNotes);
}

if (cancelNotesBtn) {
    cancelNotesBtn.addEventListener('click', cancelNotesEditing);
}

if (notesTextarea) {
    notesTextarea.addEventListener('input', () => {
        updateCharCount();
        updatePreview();
    });
    
    // Keyboard shortcuts
    notesTextarea.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
            switch (e.key) {
                case 's':
                    e.preventDefault();
                    saveNotes();
                    break;
                case 'b':
                    e.preventDefault();
                    insertFormatting('**', '**', 'bold text');
                    break;
                case 'i':
                    e.preventDefault();
                    insertFormatting('*', '*', 'italic text');
                    break;
            }
        }
        
        if (e.key === 'Escape') {
            e.preventDefault();
            cancelNotesEditing();
        }
    });
}

// Formatting button event listeners
if (formatBold) {
    formatBold.addEventListener('click', () => insertFormatting('**', '**', 'bold text'));
}

if (formatItalic) {
    formatItalic.addEventListener('click', () => insertFormatting('*', '*', 'italic text'));
}

if (formatHeader) {
    formatHeader.addEventListener('click', () => insertFormatting('## ', '', 'Header'));
}

if (formatList) {
    formatList.addEventListener('click', () => insertFormatting('- ', '', 'List item'));
}

if (formatCode) {
    formatCode.addEventListener('click', () => insertFormatting('`', '`', 'code'));
}

// Prevent page unload with unsaved changes
window.addEventListener('beforeunload', (e) => {
    if (isEditingNotes && hasUnsavedChanges()) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes to your notes. Are you sure you want to leave?';
        return e.returnValue;
    }
});

// Initialize notes on page load
initializeNotes();

</script>
{% endblock %}